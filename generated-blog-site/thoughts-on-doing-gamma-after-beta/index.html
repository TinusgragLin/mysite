<!DOCTYPE html>
<html lang="en">
    <head>
    <title>On &#x27;Do `γ` After an Outside Event `β`&#x27; - Tinusgraglin</title>
    
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"><meta name="description" content="A Slice On &#x27;Do `γ` After an Outside Event `β`&#x27; TLDR: whoever (not the source) does it do the checking."/><meta name="keywords" content="dive-into-that-lake, event-handling, multi-tasking" />
    <meta property="og:title" content="A Slice of Tgl -&nbsp;On &#x27;Do `γ` After an Outside Event `β`&#x27;" />
    <meta property="og:type" content="website"/><meta property="og:url" content="&#x2F;blog&#x2F;thoughts-on-doing-gamma-after-beta&#x2F;"/><meta property="og:description" content="TLDR: whoever (not the source) does it do the checking."/>
    <link rel="preload" href="/blog/assets/fonts/FiraCode-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="/blog/assets/fonts/FiraCode-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

    <link rel="stylesheet" href="/blog/style.css?h=97e262212a0704163528">
    <link rel="stylesheet" href=" /blog/color/orange.css?h=a5a5d7faf9d4bc3e0b18">
    
</head>
    <body>
        <div class="container center">
<header class="header">
    <div class="header__inner">
        <div class="header__logo">
            <a href="&#x2F;blog">
    <div class="logo">
        LIN
    </div>
</a>
        </div>
        <div class="menu-trigger">menu</div>
    </div>
    
    <nav class="menu">
        <ul class="menu__inner menu__inner--desktop">
            
            
                    <li>
                        <a href="
    
        /blog/about
    
">about</a>
                    </li>
                
            </ul>

        <ul class="menu__inner menu__inner--mobile">
            
        <li>
            <a href="
    
        /blog/about
    
">about</a>
        </li>
        </ul>
    </nav>

    </header>
<div class="content"><article class="post">
        <header>
            <h1 class="post-title">
                <a href="&#x2F;blog&#x2F;thoughts-on-doing-gamma-after-beta&#x2F;">On &#x27;Do `γ` After an Outside Event `β`&#x27;</a>
            </h1>
            
    <div class="post-meta">
        <span class="post-date">2024.02.03
                [Updated: 2024.02.03]
                </span>

        <span class="post-author"></span>

        

    
    :: {<a href="/blog/categories/dive-into-that-lake/">dive-into-that-lake</a>} 

            
    ::
    #<a href="/blog/tags/event-handling/">event-handling</a>
        
    #<a href="/blog/tags/multi-tasking/">multi-tasking</a>
        
    
            
        
    </div>

            
    


<div class="toc" id="nav-container">
	<p class="toc-head">Table of Contents</p>
		<div id="nav-content" >
		<ul>
		
			<li>
				<a href="/blog/thoughts-on-doing-gamma-after-beta/#thoughts-on-do-g-after-an-outside-event-b">Thoughts on &#x27;Do γ After an Outside Event β&#x27;</a>
				
					<ul>
						
							<li>
								<a href="/blog/thoughts-on-doing-gamma-after-beta/#from">From</a>
							</li>
							
						
							<li>
								<a href="/blog/thoughts-on-doing-gamma-after-beta/#to">To</a>
							</li>
							
						
					</ul>
				
			</li>
		
		</ul>
		</div>
</div>

</header><h1 id="thoughts-on-do-g-after-an-outside-event-b">Thoughts on 'Do <code>γ</code> After an Outside Event <code>β</code>'<a class="zola-anchor" href="#thoughts-on-do-g-after-an-outside-event-b" aria-label="Anchor link for: thoughts-on-do-g-after-an-outside-event-b">§</a>
</h1>
<h2 id="from">From<a class="zola-anchor" href="#from" aria-label="Anchor link for: from">§</a>
</h2>
<p>Suppose there are only two persons (<code>A</code> and <code>B</code>) in the world, and they can not
communicate. B can produce event <code>β</code>, which <code>A</code> can always observe. Now, <code>A</code>
thinks that after <code>β</code> happens, <code>γ</code> should happen. For <code>A</code>, There's only one
reliable way to make sure <code>γ</code> happens after <code>β</code>:</p>
<ul>
<li><code>A</code> needs to actively watching (or checking, polling) for the occurrence of
<code>β</code>, and also do <code>γ</code> themself.</li>
</ul>
<p>Now suppose further that <code>A</code> and <code>B</code> can communicate, now <code>A</code> has two choices:</p>
<ul>
<li>
<p><code>A</code> still does <code>γ</code> themself.</p>
<p>Then <code>A</code> still needs to be aware of the occurrence of <code>β</code>, and needs to either</p>
<ol>
<li>actively check for the occurrence of <code>β</code>, or 2) tell <code>B</code> to send a message
when <code>β</code> has happened, and then actively checking for the occurrence of the
message.</li>
</ol>
<p>So either way, <code>A</code> still needs to do some active checking.</p>
</li>
<li>
<p>Let <code>B</code> do <code>γ</code></p>
<p>In this case, after <code>A</code> tells <code>B</code> their intent, <code>B</code> does <code>γ</code> after doing <code>β</code>.</p>
</li>
</ul>
<p>Now further suppose that there is the third person <code>C</code> in the world.</p>
<ul>
<li>
<p>A still does <code>γ</code> themself.</p>
<p><code>A</code> again needs to do some active checking.</p>
</li>
<li>
<p>Let <code>B</code> do <code>γ</code>.</p>
<p>The best approach is still directly reach out to <code>B</code>.</p>
</li>
<li>
<p>Let <code>C</code> do <code>γ</code>.</p>
<p><code>C</code> is in the same situation as <code>A</code> before: wants <code>γ</code> happen after <code>β</code>, an
event not produced by themself.</p>
</li>
</ul>
<hr />
<p>One rule one might has observed so far is that whoever that is not the source of
event <code>β</code> but is responsible for actually carrying out <code>γ</code> after <code>β</code> has to be
actively checking for either the occurrence of <code>β</code> itself, or an event that
indicates the occurrence of <code>β</code>.</p>
<p>Based on this observation, we may conclude: if <code>A</code> wants <code>γ</code> to happen after
<code>β</code>, an event produced by <code>B</code>, then:</p>
<ol>
<li>
<p>Either the source of <code>β</code> (<code>B</code>) has to be informed to do <code>γ</code> after <code>β</code>.</p>
</li>
<li>
<p>Or whoever that is not <code>B</code> but is responsible for doing <code>γ</code> has to actively
checking either the occurrence of <code>β</code> itself or an event indicating it.</p>
<p>And the event indicating the occurrence of <code>β</code> could be what another person
<code>X</code> would do after the occurrence of <code>β</code>. So, yes, we could have a recursion
chain here, and at the end of this chain, it is either:</p>
<ol>
<li>somebody that is not the source of an event actively checking for the
occurrence of that event so they can do something, or,</li>
<li>the source of an event is informed to do something after that event.</li>
</ol>
</li>
</ol>
<hr />
<p>Now we focus on the 'actively checking' part above. Actively checking for just
one thing seems like a waste of time if one has something else to do / to check.
Luckily in real life a human being always checks for multiple things just about
every moment: sound, light, plans, thoughts, etc. and acts accordingly based
on the results of all these checks in a schedule. That's why one can be handling
multiple tasks at the same time. This multi-tasking ability is also implemented
in a similar way in most computer OSes, or as we shall see, most user-land
multi-tasking managing system.</p>
<h2 id="to">To<a class="zola-anchor" href="#to" aria-label="Anchor link for: to">§</a>
</h2>
<p>Now we dive into the computer world. One important fact in that world is that it
is the <em>hardware</em> that actually does all the works.</p>
<p>Specifically, it's sometimes beneficial to realize that the processors are the
real executors:</p>
<ul>
<li>
<p>OSes and user programs are simply instructions that tell the processors what
to do.</p>
</li>
<li>
<p>'Processes' and 'threads' are all abstractions created by the <em>OS</em> to manage
the execution states of programs:</p>
<ul>
<li>A process is a structure representing the state of a loaded program.</li>
<li>A thread is a structure representing the state of an execution of a sequence
of instructions inside a loaded program.</li>
</ul>
<p>In early days, the execution of an entire loaded program is the unit of the
OS's multi-task scheduling, so there is only one structure for execution state
(i.e. thread) inside a process, which people may simply call '<em>the</em> execution
state of this program'.</p>
<p>However, this way only inter-program concurrency and parallelism is exploited.
In order to support intra-program multi-tasking, the OS needs to keep multiple
execution state structures for a process and find a name for the new unit
of multi-task scheduling, so the concept of a 'thread' is used to refer to an
execution of a sequence of code inside a program. A more concrete definition
for 'threads of a process' can be 'the execution state structures the OS keeps
for each process (loaded program)'.</p>
<p>This, however, isn't enough for user programs targeting massive multi-tasking:
relying on the OS for multi-task managing and scheduling can be costly and
inflexible. Hence, the idea of a user-space multi-task manager/scheduler was
explored.</p>
<p>Since it is the OS who communicates with the hardware to make the parallelism
enabled by multiple cores possible, and 'thread' is the OS's unit of
multi-task scheduling, to enable parallelism for a user-space multi-task
system, the system needs to schedule tasks to multiple threads. This is often
referred to as the 'M:N' mapping, as in 'mapping M tasks into N threads'.</p>
<p>Some of those massive multi-task systems, however, focus on receiving and
handling a massive number of IOs rather than computation-heavy tasks, thus
choose user-space multi-task systems that schedule tasks on a single thread to
avoid having to worry about concurrency issues. This is often called 'M:1'
mapping.</p>
<p>Either way, this user-space multi-task manager needs an IO mechanism (provided
by the OS) that doesn't result in the OS stopping the execution of a thread
where an IO request was just recognized and processed until that IO request is
done, since 1) otherwise a task requesting IOs running on a thread would put
the thread into a paused state until the requested IO is done, the user-space
multi-task manager wouldn't be able to schedule other tasks to run during this
paused period, and 2) a user space program can not directly talk to the IO
devices and has to rely on the OS for that.</p>
</li>
</ul>
<p>With all the previous content presented, let's talk about, from bottom to top,
how a program is able to do <code>γ</code> after <code>β</code> where <code>β</code> is an IO event.</p>
<p>An IO device usually indicates an IO state change as a output pin, the output
pin is often connected one of the <em>interrupt request</em> pins of an <em>interrupt
controller</em> (e.g. Intel 8259), which is in turn connected to the CPU(s) (for
multi-core systems, the OS can cooperate with the interrupt controller(s) to
deliver interrupts in a specific way), the CPU(s), synchronized with the system
clock, performs a <em>check</em> to the interrupt input pin and read from the data bus
the interrupt request number the interrupt controller gives, and looks up a
table for an address corresponding to the start of an interrupt handling
procedure for the interrupt request number.</p>
<p>(NOTE: this is apparently a vastly simplified version, there are details about
interrupt priorities, acknowledgements, disabling interrupt during interrupt
handling and more)</p>
<p>The OS, fills the interrupt request number to handler address table with
addresses of procedures it has defined, so when certain interrupt comes, it is
able to adjust its state accordingly. For example, when a thread is marked
'should-not-be-scheduled' for waiting for an IO request, it can be marked
'can-be-scheduled' again by the OS after an interrupt indicates the completion
of the IO request.</p>
<p>The user program can then make use of one of the IO notification / completion
handling infrastructures provided by the OS to do <code>γ</code> after <code>β</code>.</p>
<p>As can be seen above, the root is that each processor, at each clock cycle,
<strong>actively checking</strong> for an occurrence of some interrupt signal. Now combining
with the discussion from first section, there are two ways to think about this:</p>
<ol>
<li>
<p>Since a program is nothing more than instructions for the processor, it can
be said that the processor itself wants to do <code>γ</code> after <code>β</code>, and thus choose
to actively checking for the occurrence of <code>β</code>.</p>
</li>
<li>
<p>Or, each sequence of code organized for certain 'task', the internal logic of
the processor (e.g. the way it reads and execute instructions and handle
interrupts) or that of any other hardware can be thought of as a different
person. So, for example, some part of the OS wants to do <code>γ</code> after <code>β</code> (some
interrupt request), it knows that the processor logic will do <code>δ</code> (jumping to
some address) after <code>β</code>, so now it wants to do <code>γ</code> after <code>δ</code>, it informs the
processor logic about this intention by effectively altering the <strong>exact</strong>
behavior of the processor logic in the way of changing a part of its memory.</p>
<p>Now, for any 'task' except for the OS's scheduler, however, its 'liveness' or
'being alive' or 'being able to experience the time' is controlled and
scheduled by the OS scheduler, so if it wants to do <code>γ</code> after <code>β</code>, an event
not produced by itself, the scheduler can pause the execution of this task
when this intention is understood and resume it after <code>β</code> happens. As far as
the 'task' is concerned, after the intention is sent, it simply time-leap to
a future after <code>β</code> happened, and thus happily start to do <code>γ</code>. The original
intention of do <code>γ</code> after <code>β</code> effectively gets translated to 'pause the
execution until the OS is aware of some condition is true', <em>this</em>, however,
is just <strong>informing the OS to do something (resuming execution of a thread)
after an event happens.</strong></p>
<p>A good example for this other than IO request would be how <code>pthread_wait</code> is
implemented: 1) <code>pthread_wait</code> would call a <code>futex</code> system call that pauses
further execution of the current thread and also push it into the <code>join</code>ed
thread's completion waiting queue, 2) any thread managed by <code>pthread</code> library
calls <code>pthread_exit</code> when it exits if it does not call <code>exit</code> first, in which
case the whole process terminates and 3) <code>pthread_exit</code> calls another <code>futex</code>
system call that wakes up all threads in the completion waiting queue of the
current thread. In this example, the calling thread's intention of running
some code after the completion of the <code>join</code>ed thread is translated by the
<code>pthread</code> lib to 'pause the execution until the OS is aware that the calling
thread is removed from a <code>futex</code> waiting queue'.</p>
</li>
</ol>


        
    

        
        
    </article></div>
    <div class="pagination">
        <div class="pagination__buttons">
            </div>
    </div>
<footer class="footer">
                    <div class="footer__inner"><div class="copyright">
            <span>© 2024 Tinusgraglin <span/>
            <span>:: Powered by <a href="https://www.getzola.org/">Zola</a>(<a href="https://www.rust-lang.org/">Rust</a>) and <a href="https://bun.sh">Bun</a>(<a href="https://ziglang.org">Zig</a>)</span>
        </div>
    <script type="text/javascript" src="/blog/assets/js/main.js"></script>
</div>
                    

                </footer></div>
    </body>
</html>
