<!DOCTYPE html>
<html lang="en">
    <head>
    <title>Proj Ryndoki - Thoughts - 0 - Tinusgraglin</title>
    
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"><meta name="description" content="A Slice Proj Ryndoki - Thoughts - 0 (WIP) Thoughts on designing a file sync tool."/><meta name="keywords" content="thoughts-of-designing, ryndoki, sync-tool" />
    <meta property="og:title" content="A Slice of Tgl -&nbsp;Proj Ryndoki - Thoughts - 0" />
    <meta property="og:type" content="website"/><meta property="og:url" content="&#x2F;blog&#x2F;ryndoki-design-0&#x2F;"/><meta property="og:description" content="(WIP) Thoughts on designing a file sync tool."/>
    <link rel="preload" href="/blog/assets/fonts/FiraCode-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="/blog/assets/fonts/FiraCode-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

    <link rel="stylesheet" href="/blog/style.css?h=97e262212a0704163528">
    <link rel="stylesheet" href=" /blog/color/orange.css?h=a5a5d7faf9d4bc3e0b18">
    
</head>
    <body>
        <div class="container center">
<header class="header">
    <div class="header__inner">
        <div class="header__logo">
            <a href="&#x2F;blog">
    <div class="logo">
        LIN
    </div>
</a>
        </div>
        <div class="menu-trigger">menu</div>
    </div>
    
    <nav class="menu">
        <ul class="menu__inner menu__inner--desktop">
            
            
                    <li>
                        <a href="
    
        /blog/about
    
">about</a>
                    </li>
                
            </ul>

        <ul class="menu__inner menu__inner--mobile">
            
        <li>
            <a href="
    
        /blog/about
    
">about</a>
        </li>
        </ul>
    </nav>

    </header>
<div class="content"><article class="post">
        <header>
            <h1 class="post-title">
                <a href="&#x2F;blog&#x2F;ryndoki-design-0&#x2F;">Proj Ryndoki - Thoughts - 0</a>
            </h1>
            
    <div class="post-meta">
        <span class="post-date">2023.03.13
                [Updated: 2023.03.17]
                </span>

        <span class="post-author"></span>

        

    
    :: {<a href="/blog/categories/thoughts-of-designing/">thoughts-of-designing</a>} 

            
    ::
    #<a href="/blog/tags/ryndoki/">ryndoki</a>
        
    #<a href="/blog/tags/sync-tool/">sync-tool</a>
        
    
            
        
    </div>

            
    


<div class="toc" id="nav-container">
	<p class="toc-head">Table of Contents</p>
		<div id="nav-content" >
		<ul>
		
			<li>
				<a href="/blog/ryndoki-design-0/#general-design-thoughts-for-ryndoki-a-sync-tool">General Design Thoughts for Ryndoki, a Sync Tool</a>
				
					<ul>
						
							<li>
								<a href="/blog/ryndoki-design-0/#project-naming">Project Naming</a>
							</li>
							
						
							<li>
								<a href="/blog/ryndoki-design-0/#user-data-hierarchical-organization">User data hierarchical organization:</a>
							</li>
							
								<ul>
								
									<li>
										<a href="/blog/ryndoki-design-0/#workspaces">Workspaces</a>
										
									</li>
								
									<li>
										<a href="/blog/ryndoki-design-0/#data-source">Data source</a>
										
									</li>
								
									<li>
										<a href="/blog/ryndoki-design-0/#repository">Repository</a>
										
									</li>
								
									<li>
										<a href="/blog/ryndoki-design-0/#files-dirs-identified-by-a-path-within-its-residing-repository">Files&#x2F;Dirs (identified by a path within its residing repository)</a>
										
									</li>
								
								</ul>
							
						
							<li>
								<a href="/blog/ryndoki-design-0/#safety-concerns-with-authentications-and-authorizations-control">Safety concerns with authentications and authorizations control</a>
							</li>
							
								<ul>
								
									<li>
										<a href="/blog/ryndoki-design-0/#a-exposure-problem">A Exposure Problem</a>
										
									</li>
								
									<li>
										<a href="/blog/ryndoki-design-0/#authentications">Authentications</a>
										
									</li>
								
									<li>
										<a href="/blog/ryndoki-design-0/#client-authorizations-access-controls">Client Authorizations (Access Controls)</a>
										
											<ul>
												
													<li>
														<a href="/blog/ryndoki-design-0/#accesses-to-repos">Accesses to Repos</a>
													</li>
													
												
													<li>
														<a href="/blog/ryndoki-design-0/#visible-level">Visible level</a>
													</li>
													
												
													<li>
														<a href="/blog/ryndoki-design-0/#contributor-collaborator-membership">Contributor&#x2F;Collaborator Membership</a>
													</li>
													
												
											</ul>
										
									</li>
								
									<li>
										<a href="/blog/ryndoki-design-0/#accesses-to-data-sources">Accesses to Data Sources</a>
										
									</li>
								
								</ul>
							
						
							<li>
								<a href="/blog/ryndoki-design-0/#synchronization">Synchronization</a>
							</li>
							
								<ul>
								
									<li>
										<a href="/blog/ryndoki-design-0/#versioning">Versioning</a>
										
									</li>
								
									<li>
										<a href="/blog/ryndoki-design-0/#general-synchronization-datapath">General Synchronization Datapath</a>
										
									</li>
								
									<li>
										<a href="/blog/ryndoki-design-0/#multi-clients-synchronization">Multi-clients Synchronization</a>
										
											<ul>
												
													<li>
														<a href="/blog/ryndoki-design-0/#general-multi-clients-synchronization-process">General Multi-clients Synchronization Process</a>
													</li>
													
												
													<li>
														<a href="/blog/ryndoki-design-0/#contributors-and-collaborators">Contributors and Collaborators</a>
													</li>
													
												
											</ul>
										
									</li>
								
								</ul>
							
						
							<li>
								<a href="/blog/ryndoki-design-0/#client-operations-overview">Client Operations Overview</a>
							</li>
							
						
							<li>
								<a href="/blog/ryndoki-design-0/#components-services-summaries">Components Services Summaries</a>
							</li>
							
						
							<li>
								<a href="/blog/ryndoki-design-0/#components-definitions">Components Definitions</a>
							</li>
							
						
							<li>
								<a href="/blog/ryndoki-design-0/#major-flows">Major Flows</a>
							</li>
							
						
					</ul>
				
			</li>
		
		</ul>
		</div>
</div>

</header><h1 id="general-design-thoughts-for-ryndoki-a-sync-tool">General Design Thoughts for Ryndoki, a Sync Tool<a class="zola-anchor" href="#general-design-thoughts-for-ryndoki-a-sync-tool" aria-label="Anchor link for: general-design-thoughts-for-ryndoki-a-sync-tool">§</a>
</h1>
<h2 id="project-naming">Project Naming<a class="zola-anchor" href="#project-naming" aria-label="Anchor link for: project-naming">§</a>
</h2>
<p>Rust + Sync + dōki(同期)</p>
<h2 id="user-data-hierarchical-organization">User data hierarchical organization:<a class="zola-anchor" href="#user-data-hierarchical-organization" aria-label="Anchor link for: user-data-hierarchical-organization">§</a>
</h2>
<h3 id="workspaces">Workspaces<a class="zola-anchor" href="#workspaces" aria-label="Anchor link for: workspaces">§</a>
</h3>
<p>A workspace is per-user data storage, containing all the data a user works with. It is conceptually the root repo of a user.</p>
<h3 id="data-source">Data source<a class="zola-anchor" href="#data-source" aria-label="Anchor link for: data-source">§</a>
</h3>
<p>An abstraction of a place user data can be retrieved and stored. It consists
of multiple repositories each contains a set of related files.
A data source should be able to:</p>
<ul>
<li>Reveal some of its meta data</li>
<li>Give duplication information when the fingerprint of a updated version of
an existing file is given</li>
<li>Accept an update of an existing file</li>
<li>Give updates to an file</li>
</ul>
<h3 id="repository">Repository<a class="zola-anchor" href="#repository" aria-label="Anchor link for: repository">§</a>
</h3>
<p>An abstraction of a set of logically related, hierarchically structured data.</p>
<p>A repo can be created in, sync to and sync from an existing data source. (or data sources? Allowing replicated synchronization?)</p>
<p>To allow synchronized sharing and collaboration, a user's repo can contain references to other people's repo, or files/dirs from
other people's repo. An 'immutable' reference let you always have a latest copy of the data but you can not have your modifications
seen by other people while a 'mutable' reference, which you can acquire through a contributor or a collaborator membership of a
repo, allows your modifications to be seen.</p>
<ul>
<li>
<p>On the idea of a central place where a user can check out other people's repos and refs their contents:</p>
<ul>
<li>What a user is able to see
<ol>
<li>Information of a repo itself:<br />
owner, contributor, collaborator, name, visibility level, modification time, revision history</li>
<li>Content of a repo:<br />
repo structure (refs included), each file's name, modification time, revision history</li>
</ol>
</li>
<li>What a user is able to do:
<ol>
<li>Send contributor or collaborator membership request to a repo's owner</li>
<li>Download to local (workspace not included), or clone, immutably or (if a membership of contributor or collaborator is
obtained) mutably refs content into the user's repo</li>
</ol>
</li>
</ul>
</li>
<li>
<p>On how we should represent refs:</p>
<ol>
<li>
<p>Store all refs' info in a repo's meta data (preferred)
When this piece of meta data is needed:</p>
<ol>
<li>A client wants to check out other people's repos and their content.</li>
<li>A client wants SyncTo/SyncFrom of a repo possibly containing refs and wants to know the refs' destinations.<br />
(this task could delegate to aggregated data sources)</li>
</ol>
<p>Where this piece of meta data should be stored:</p>
<ol>
<li>Aggregated data sources
<ul>
<li>Since the global data server also need this info, the global data server could hear from all aggregated data sources and cache
the data, the initial cache could be updated by aggregated data source heart beat msg.</li>
<li>When a ref is added to a repo, it is considered as a change but instead of starting normal delta sync process,
<ol>
<li>A msg is send to the data source to inform it this meta data change of the repo</li>
<li>The data source should ack this msg and also gives the info of the data source where the repo the ref refs to resides
so that the client can retrieve some real data.</li>
<li>After the ack is received at the client's side, the client set up a listening channel for any change of the refed data.</li>
</ol>
</li>
<li>When a ref in a repo is removed by the user,
<ol>
<li>A msg is sent to the data source to inform it the removal.</li>
</ol>
</li>
</ul>
</li>
<li>Global meta data server</li>
</ol>
</li>
<li>
<p>Using a special file format to represent a ref in its place</p>
</li>
</ol>
</li>
</ul>
<h3 id="files-dirs-identified-by-a-path-within-its-residing-repository">Files/Dirs (identified by a path within its residing repository)<a class="zola-anchor" href="#files-dirs-identified-by-a-path-within-its-residing-repository" aria-label="Anchor link for: files-dirs-identified-by-a-path-within-its-residing-repository">§</a>
</h3>
<h2 id="safety-concerns-with-authentications-and-authorizations-control">Safety concerns with authentications and authorizations control<a class="zola-anchor" href="#safety-concerns-with-authentications-and-authorizations-control" aria-label="Anchor link for: safety-concerns-with-authentications-and-authorizations-control">§</a>
</h2>
<h3 id="a-exposure-problem">A Exposure Problem<a class="zola-anchor" href="#a-exposure-problem" aria-label="Anchor link for: a-exposure-problem">§</a>
</h3>
<p>Consideration 1: A data source should be just a port data can flow, it should not
expose the local or remote sources it drains data from/pushes data to.<br />
Consideration 2: A user can create a new repo which is stored in the local storage of
a data source, and he/she should be able to add refers to data in other repos stored in
some other remote sources to the repo. That is, A user should be able to check out 
repos in some remote sources.</p>
<ul>
<li>A client should only be able to check out repos of remote sources from a central meta
data server.</li>
</ul>
<h3 id="authentications">Authentications<a class="zola-anchor" href="#authentications" aria-label="Anchor link for: authentications">§</a>
</h3>
<p>To authenticate a client, we have a few choices:</p>
<ol>
<li>TLS client cert request with some kind of client identification (e.g. Email address)</li>
<li>Account password based authentication with some kind of client identification (e.g. Email address)</li>
</ol>
<p>I would choose 1 for the sake of implementation simplicity. In this case, a client need to generate
key pairs with his email address and has the CA sign a certificate it can later use to communicate
with various servers.</p>
<p>First, any server a client can connect to needs cert, this includes: aggregated server, global meta
data server, message servers, in all of these connections, the client needs also to be authenticated,
so we need two way TLS for all of these connections.</p>
<p>Second, in the cases of a aggregated server connects to the message server or the global meta server as
well as a trivial data source, the server and the client both needs to be verified, so we again need two
way TLS.</p>
<p>A client, a aggregated server, a trivial data sources can play the role of a 'client'.<br />
An aggregated server, a global meta server, a message server can play the role of a 'server'.</p>
<p>In a one way TLS, the client need to trust the CA, and the server needs a cert signed by the CA.
In a two way TLS, the client and server both need to have a cert signed by the CA and also trust the CA
and have the CA's cert and pub key.</p>
<p>ALL components in our system needs to talk to the CA server.</p>
<p>Or maybe the second category don't actually need two way, then:</p>
<ol>
<li>Only clients, aggregated servers, global meta data server, message servers needs cert signed by CA and
also to trust CA.</li>
<li>Trivial data sources only need cert.</li>
</ol>
<p>Or maybe only the connection between a trivial data source and an aggregated data source don't need two way
auth, then the requirements list are the same as above. </p>
<p>But with the set up of a CA server, we need to solve the problem of cert revocation. With OCSP stapling,
we can check the status of 'server role' cert. For 'client role' cert status check, it is not clear
whether it is supported in common implementations or not. We can manually implement similar thing, though,
i.e. have the client send a CA signed time-stamped OCSP response to the server.</p>
<p>Summary: </p>
<ol>
<li>Clients, aggregated servers, global meta data server, message servers needs cert signed by CA and
also CA's public key and cert.</li>
<li>Trivial data sources only need cert signed by CA.</li>
</ol>
<h3 id="client-authorizations-access-controls">Client Authorizations (Access Controls)<a class="zola-anchor" href="#client-authorizations-access-controls" aria-label="Anchor link for: client-authorizations-access-controls">§</a>
</h3>
<h4 id="accesses-to-repos">Accesses to Repos<a class="zola-anchor" href="#accesses-to-repos" aria-label="Anchor link for: accesses-to-repos">§</a>
</h4>
<p>To a client, a repo can be:</p>
<ol>
<li>Invisible</li>
<li>Visible but not modifiable</li>
<li>Visible and modifiable but changes to the repo need to be approved (Contributor)</li>
<li>Visible and modifiable, changes to the repo need not to be approved and you can approve other people'
changes. (Owner and Collaborator)</li>
</ol>
<p>Division of 1 and 2 is done by visible level, 2, 3 and 4 by the concept of contributors and collaborators.</p>
<h4 id="visible-level">Visible level<a class="zola-anchor" href="#visible-level" aria-label="Anchor link for: visible-level">§</a>
</h4>
<ol>
<li>A client has a privilege level.</li>
<li>A client is given the lowest upon registration.</li>
<li>A repo has a visibility level. </li>
<li>A client is only allowed to create and see repos no higher than his/her privilege level. </li>
<li>A client can request a higher privilege level from a central server, this request will be approved
or denied by management team.<br />
Repos owned by the client before this level ascension not are changed in any way.</li>
<li>The management team can lower a client's privilege level on the central server. Before they can
do this, they should decide what to do with repos of this client that has a higher visibility level
than the descended privilege level, for each of these repo, they can change the owner of it to
someone whose privilege level is no lower than the repo's visibility level, in which case that
person has to agree on this for the transition of ownership to be done, or they can simply discard it.</li>
<li>The owner of a repo can increase or decrease the repo's visibility level as long as it's not above
the owner's privilege level.<br />
When a repo level ascension is done, less people should be able to see it, thus this msg should be
immediately consumed by all concerned roles. 
When a repo descension is done, more people should be able to see it, thus the msg can be delayed.</li>
</ol>
<ul>
<li>Where this info should be stored
<ol>
<li>A client's privilege level
<ul>
<li>When this info will be needed:
<ol>
<li>A client wants to create his/her repo</li>
<li>A client wants to change his/her repo's level</li>
<li>A client wants to check other people's repos</li>
</ol>
</li>
<li>Possible candidates:
<ol>
<li>global meta server</li>
</ol>
</li>
</ul>
</li>
<li>The visibility level of a repo owned by a client
<ul>
<li>When this info will be needed:
<ol>
<li>A client wants to check other people's repos</li>
</ol>
</li>
<li>Possible candidates:
<ol>
<li>global meta server</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="contributor-collaborator-membership">Contributor/Collaborator Membership<a class="zola-anchor" href="#contributor-collaborator-membership" aria-label="Anchor link for: contributor-collaborator-membership">§</a>
</h4>
<ol>
<li>
<p>A client can request contributor/collaborator membership of a repo from the owner of that repo. This request
should be sent to the repo owner via message server. (the client should listen to, say, a 'notifications'
channel) The owner of the repo, upon reception of this request, should approve or deny it. </p>
</li>
<li>
<p>An aggregated data source, upon receiving a change push request to one of its repo data, should verify the
originator of the change.</p>
</li>
</ol>
<ul>
<li>
<p>When this info is needed</p>
<ol>
<li>A data source wants to verify whether changes to a repo from a client are valid.</li>
<li>A repo's owner want to check all contributors and collaborators.</li>
</ol>
</li>
<li>
<p>Where this info should be stored</p>
<ol>
<li>(Aggregated) Data sources</li>
</ol>
</li>
</ul>
<h3 id="accesses-to-data-sources">Accesses to Data Sources<a class="zola-anchor" href="#accesses-to-data-sources" aria-label="Anchor link for: accesses-to-data-sources">§</a>
</h3>
<p>To a client, an aggregated data source can be:</p>
<ol>
<li>Visible but not appendable </li>
<li>Visible and appendable</li>
</ol>
<p>Division of 1 and 2 is done by appending permitted list.</p>
<p>Two forms:</p>
<ol>
<li>Appending permitted list for a data source<br />
A data source initially has an appending permitted list of zero entry.</li>
<li>Appending permitted list for a client (this is <strong>preferred</strong> currently)<br />
A client initially has an appending permitted list of zero entry.</li>
</ol>
<p>In general:</p>
<ul>
<li>When a client want appending permission for a data source, a request to the central server
should be send and management team should approve or deny the request.<br />
The data source could send the request of behalf of the client so that itself, as a concerned
role in this process, directly get the right info. In this case, the client should turns to
the data source for permission request.</li>
<li>The management team can revoke the appending permission to a data source of a client. All of
The clients' repos residing in the data source should not be removed until the client is fully
informed, the client should be able to download all these repos before they are removed from
the data source.<br />
This revocation should be known to the data source.<br />
To prevent the client to push his/her changes to its repos already at the data source or create
a new repo after the management sends the msg to the data source but before the data source receives
it, a data source is required to check the permission before any modification to its content can be
made, revocation messages from the central server, however, can still be sent to timely inform the
data source.<br />
The cleaning process starts as soon as the central server or data source can talk to the client.<br />
The revocation can also be sent the message server to notify the client.</li>
</ul>
<h2 id="synchronization">Synchronization<a class="zola-anchor" href="#synchronization" aria-label="Anchor link for: synchronization">§</a>
</h2>
<h3 id="versioning">Versioning<a class="zola-anchor" href="#versioning" aria-label="Anchor link for: versioning">§</a>
</h3>
<p>To have unique versioning, we version each revision of a repo combining the client identify of the
last change and the last change's modifier-local modification numbering, for example, a revision
history of a repo might look like this:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>(Owner: Mike)
</span><span>
</span><span>Mike&#39;s 1st Modification
</span><span>Mike&#39;s 2nd Modification
</span><span>Mike&#39;s 3rd Modification
</span><span>Mike&#39;s 4th Modification
</span><span>Alice&#39;s 1st Modification
</span><span>Alice&#39;s 2nd Modification
</span><span>Mike&#39;s 5th Modification
</span><span>Bob&#39;s 1st Modification
</span><span>Alice&#39;s 3rd Modification
</span><span>Bob&#39;s 2nd Modification
</span><span>Bob&#39;s 3rd Modification
</span></code></pre>
<p>Because, for example, there won't be two &quot;Mike's 2nd Modification&quot; (in a single branch of history), we
can use a tuple <code>(ModifierID, ModifierLocalModificationID)</code> to uniquely identify a revision.</p>
<p>This versioning should be enabled even in cases where there isn't any sharing <strong>yet</strong>.</p>
<p>For the definition of one modification, we adopt the widely used Open-to-Close with modification check
mechanism i.e. a new version is given when a client close a file he/she earlier opened for modification
and modification time check indicates a modification are indeed made.</p>
<h3 id="general-synchronization-datapath">General Synchronization Datapath<a class="zola-anchor" href="#general-synchronization-datapath" aria-label="Anchor link for: general-synchronization-datapath">§</a>
</h3>
<ul>
<li>Client changes sync to data source (SyncTo)
<ol>
<li>Non-ref content changes:<br />
The client can directly forwards these changes to the data source.</li>
<li>Ref content changes:<br />
The client could ask the data source to give the address of related data sources and directly forwards
changes to these data sources.</li>
</ol>
</li>
<li>Other clients' changes to the client's repo sync to local client (SyncFrom)
<ol>
<li>Non-ref content changes:<br />
The client listen to a dedicated channel for all non-ref content changes.</li>
<li>Ref content changes:<br />
The client listen to a channel for each of the root ref content.</li>
</ol>
</li>
</ul>
<h3 id="multi-clients-synchronization">Multi-clients Synchronization<a class="zola-anchor" href="#multi-clients-synchronization" aria-label="Anchor link for: multi-clients-synchronization">§</a>
</h3>
<p>In Ryndoki, multi-clients synchronization is supported through the concepts of contributors and collaborators.</p>
<h4 id="general-multi-clients-synchronization-process">General Multi-clients Synchronization Process<a class="zola-anchor" href="#general-multi-clients-synchronization-process" aria-label="Anchor link for: general-multi-clients-synchronization-process">§</a>
</h4>
<p>When no file is opened, SyncFrom is always active. When a file is opened for read, SyncFrom is delayed until
the file is closed, and carried out normally. When a file is opened for write, we may:</p>
<ol>
<li>pause SyncFrom, issue a file lock to the data source, after the file lock is confirmed and the (locked) newest
version of the file is known, and then either 
<ol>
<li>the file is not allowed to be modified until SyncFrom is carried out and all necessary updates are performed
to make the local version the newest, and after the file is closed, modifications are checked, and after the
modification (if any) is confirmed by the data source, lock is released and SyncFrom is resumed OR</li>
<li>if hijacking fs calls is hard, prompt the client to close the file meanwhile download the newest version of
the file directly from the data source and after the file is closed, modification time is checked and if no
modification is carried out, cancel the downloading if it is still going on or simply replace the old file
with the downloaded file if the download is completed, and then issue an unlock, resume SyncFrom, if, on the
other hand, modifications are carried out, the downloading is made sure to be completed, the client's file
is renamed, the downloaded file takes the original place and the two files are presented to the client. Note
that the lock is still there at this moment, the client has to decide what the final version is going to be
within a fixed amount of time, if the client responded with a final version, the final version is selected
to be the next version and normal logic applies, if the client fails to respond with a final version within
that amount of time, the client's version is moved to a special folder, lock's released and SyncFrom's resumed.</li>
</ol>
</li>
</ol>
<h4 id="contributors-and-collaborators">Contributors and Collaborators<a class="zola-anchor" href="#contributors-and-collaborators" aria-label="Anchor link for: contributors-and-collaborators">§</a>
</h4>
<p>The only difference between contributors and collaborators are really whether the confirmation of changes are
delayed until the changes are approved.<br />
Specifically, the 'file close' is done after the approval of changes for a contributor.</p>
<h2 id="client-operations-overview">Client Operations Overview<a class="zola-anchor" href="#client-operations-overview" aria-label="Anchor link for: client-operations-overview">§</a>
</h2>
<ul>
<li>
<p>A client first need to register its identify. An email address is needed and verified via email
verification code, then</p>
</li>
<li>
<p>As a client, you need to create a dedicated workspace directory, where all your repos and repo
refs are contained.</p>
</li>
<li>
<p>As a client, you either want to create your own repo, or check out and maybe work on repos
created by others.</p>
<p>You can create a repo with a level of privilege no higher than yourself and have it stored in
a data source if you have write/create permission of that data source, for that, you need to talk
to the central server that manages the data source.</p>
<p>You can ask the global meta server for a list of repos (visible to your level) from different
data sources. You can check, download, fork* or immutably ref all the repos visible to you or
some files/dirs within these repos, but if you want to modify something within a repo and have
the change sync to the original repo, you would ask the owner of the repo for a collaborator
membership and then you can mutably ref either files/directories within that repo or the repo
itself.</p>
<p>You own a repo you created, that means you can check out, push changes to and delete the repo
as well as invite collaborators who can check and push changes to, but not delete the repo,
any others are only able to check the repo.</p>
<p>*fork: a hard copy of some content to your repo, a forked content is owned by you and changes to
it will not affect the original. It's like first download the content to your local storage and
then upload to your own repo.</p>
</li>
<li>
<p>Now, you might have your own repo(s) that might refer to files/dirs from other repos or refs to
other repos within your workspace, you might want:</p>
<ol>
<li>
<p>Modifications to your own files/dirs or some 'mutable' refs to be uploaded.</p>
<p>This is done by having a watcher at background and notify the program whenever a change has
been made to these files. Whenever changes to a file is detected, the client program divides
the file into chunks, calculates their 'fingerprint', and send all of these fingerprints,
along with the file identification, modification time and other meta data to the data source
this file resides, the data source then gives possible duplicated chunks of the to-be uploaded
file, after the client program confirm the duplications, it only sends non-duplicated chunks
along with meta data to the data source, the data source then reconstruct the new file.</p>
</li>
<li>
<p>Other users' modifications to your refs or your own files/dirs mutably refed by your repo's 
collaborators to be synced.</p>
<p>This is done by setting up the client program to listen to certain message channels, more
specifically, we should listen to channels corresponding to the root refs of all the refs
in your repo, and also a channel dedicated for all non-ref content within our repo.</p>
<p>To listen to a channel, we need to send the client's identification, info of the channel we
want to listen to</p>
</li>
</ol>
</li>
</ul>
<h2 id="components-services-summaries">Components Services Summaries<a class="zola-anchor" href="#components-services-summaries" aria-label="Anchor link for: components-services-summaries">§</a>
</h2>
<p>Central meta data server services:</p>
<ul>
<li>Store info of all data sources and repos stored in these data sources. </li>
<li>Provide a way for a user to retrieve this info (or, more precisely, a part of it that the user
is able to see).</li>
<li>Info of a data source includes:
its address, info of all repos it contains</li>
<li>Info of a repo includes: 
name(or any identifier), owner, contributor, collaborator, name, visibility level, modification time, revision history</li>
</ul>
<h2 id="components-definitions">Components Definitions<a class="zola-anchor" href="#components-definitions" aria-label="Anchor link for: components-definitions">§</a>
</h2>
<ol>
<li>
<p>Trivial Data Sources<br />
A trivial data source manages a local storage it resides in.</p>
</li>
<li>
<p>Aggregated Data Sources<br />
A aggregated data source manages multiple local trivial data sources, caches information
about remote data sources from the central server (so that clients don't have to frequently
talk to central servers), stores information of repos resides here.
It is responsible for handling client requests and forwards any changes to its local
data sources made by clients to message servers.</p>
</li>
<li>
<p>Global Meta Data Server(s)<br />
The central server/cluster aggregating information about all (trusted) aggregated data
sources and clients.<br />
It is responsible for (relatively) securely including aggregated data sources and clients
to the system and providing verifications of aggregated data sources and clients.</p>
</li>
<li>
<p>Message Server(s)<br />
Message servers accepts file change messages from all data sources and forwards them
to clients.</p>
</li>
<li>
<p>CA Server(s) (with OCSP) 
Provide certificates signing services, store information about all signed certificates
and also give information about revoked certs.</p>
</li>
<li>
<p>Clients</p>
</li>
</ol>
<h2 id="major-flows">Major Flows<a class="zola-anchor" href="#major-flows" aria-label="Anchor link for: major-flows">§</a>
</h2>
<ul>
<li>Servers set up
<ol>
<li>
<p>All servers required to have a cert need first to get one from CA server.</p>
</li>
<li>
<p>An aggregated data source broadcast msg to learn about data sources, data sources reply with its
identify and cert. The aggregated data source then ask about their repo info, which can contain
refs to remote data sources, the aggregated data source then declare its existence to global meta
data server by connecting to it, after authentication, the aggregated data source reports some 
meta info (which client can access it) and its repos and expects the global meta data server to</p>
<ol>
<li>Check meta info (e.g. to see if a client is still ok to have an access to the aggregated server)
and store it.</li>
<li>Check repo info (e.g. to see if an owner of a repo can still own it) and cache it.</li>
<li>Give info of remote data sources these repo refers to so that the aggregated server can cache it.
Later changes of these info should also be sent from the global meta server.</li>
</ol>
<p>An aggregated server should also try to connect to a message server to forward info of its repos'
changes. After authentications, it sends all of its repos' non-ref content info so that the message
server can make one channel for each of the repos to forward all non-ref content changes of that repo.</p>
<p>Since the global meta server caches repo info, an aggregated server should also periodically report
repo meta data changes, this also serves as a heart beat to let the global meta know everything is
working correctly.</p>
</li>
<li>
<p>A data source listens for some aggregated source's polling msg and responds to it accordingly. It also
should send heartbeat to let the aggregated server know everything is working correctly.</p>
</li>
<li>
<p>A global meta server waits for aggregated data sources' connections and record their meta info and caches
their repo info, note that the list of data sources are written to disk and upon next restart, it would
respond 'reconnect' to all heart beat msgs, after a while, if these is still a data source in the list
whose heart beat is not received, a data source failure would be reported.<br />
A global meta server also caches data sources' mutation permitted lists, which are also updated via heart
beat.<br />
Note that all of these caches should be confirmed when the client is ready to do real things.<br />
A global meta server stores clients info (e.g. email, status, level of privilege, etc.)</p>
</li>
<li></li>
</ol>
</li>
</ul>


        
    

        
        
    </article></div>
    <div class="pagination">
        <div class="pagination__buttons">
            </div>
    </div>
<footer class="footer">
                    <div class="footer__inner"><div class="copyright">
            <span>© 2024 Tinusgraglin <span/>
            <span>:: Powered by <a href="https://www.getzola.org/">Zola</a>(<a href="https://www.rust-lang.org/">Rust</a>) and <a href="https://bun.sh">Bun</a>(<a href="https://ziglang.org">Zig</a>)</span>
        </div>
    <script type="text/javascript" src="/blog/assets/js/main.js"></script>
</div>
                    

                </footer></div>
    </body>
</html>
